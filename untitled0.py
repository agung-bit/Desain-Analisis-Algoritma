# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tVnO2Smrqv7sDaq0XD2Em_MS9t6XOI5l
"""

import matplotlib.pyplot as plt
import math
import copy
import time

start = time.time()

class titik():
	def __init__(self, x, y):
		self.x = x
		self.y = y

p=[titik(3,6),titik(9,12),titik(2,4),titik(6,8),titik(11,5),titik(12,14),titik(7,10),titik(16,20)]

for i in p:
  plt.scatter(i.x, i.y, s=50)
  plt.title("posisi tiitk")
plt.show()

def dist(p1, p2):
	return math.sqrt((p1.x - p2.x) *
					(p1.x - p2.x) +
					(p1.y - p2.y) *
					(p1.y - p2.y))

def bruteForce(P, n):
	min_val = float('inf')
	for i in range(n):
		for j in range(i + 1, n):
			if dist(P[i], P[j]) < min_val:
				min_val = dist(P[i], P[j])

	return min_val


def divide(p,q,n):
	if n <= 3:
		return bruteForce(p, n)
	mid = n // 2
	midPoint = p[mid]

	Pl = p[:mid]
	Pr = p[mid:]
	dl = divide(Pl,q, mid)
	dr = divide(Pr,q, n - mid)
	d = min(dl, dr)

	stripP = []
	stripQ = []
	lr = Pl + Pr
	for i in range(n):
		if abs(lr[i].x - midPoint.x) < d:
			stripP.append(lr[i])
		if abs(lr[i].x - midPoint.x) < d:
			stripQ.append(lr[i])

	stripP.sort(key = lambda point: point.y)
	min_a = min(d, combine(stripP, len(stripP), d))
	min_b = min(d, combine(stripQ, len(stripQ), d))
	
	return min(min_a,min_b)
def combine(strip, size, d):
	min_val = d
	for i in range(size):
		j = i + 1
		while j < size and (strip[j].y -
							strip[i].y) < min_val:
			min_val = dist(strip[i], strip[j])
			j += 1
	return min_val

def closest(P, n):
	P.sort(key = lambda point: point.x)
	Q = copy.deepcopy(P)
	Q.sort(key = lambda point: point.y)
	return divide(P, Q, n)

n = len(p)
print(closest(p, n))
end = time.time()
print(f"Runtime of the program is {end - start}")